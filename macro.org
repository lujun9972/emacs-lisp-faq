#+TITLE: macro
#+AUTHOR: DarkSun
#+CATEGORY: emacs-lisp-faq
#+DATE: [2016-02-02 周二 16:10]
#+OPTIONS: ^:{}

* 如何统计程序消耗的时间
使用如下宏,可以粗略地统计程序消耗的时间
#+BEGIN_SRC emacs-lisp
  (defmacro time (&rest bodys)
    (let ((start-time (gensym)))
      `(let ((,start-time (current-time)))
         ,@bodys
         (message "pasted time %fs" (float-time (time-subtract (current-time) ,start-time))))))
#+END_SRC
只需要将要统计的程序放在time宏内即可
#+BEGIN_SRC emacs-lisp
  (time (sit-for 10))                     ; "pasted time 10.030574s"
#+END_SRC

* 对宏中带有副作用参数的预处理方式
#+BEGIN_SRC emacs-lisp
  (defmacro pretreat_args (&rest args)
    (let ((pretreated_args (cl-gensym)))
      `(let ((,pretreated_args (list ,@args)))
         (其他操作))))

  (macroexpand '(pretreat_args (incf a) (incf b)))
  ;; (let ((G66686 (list (incf a) (incf b))))
  ;;   (其他操作))
#+END_SRC
* 惰性求值
通过宏将一系列计算封装为函数,就能实现惰性求值了
#+BEGIN_SRC emacs-lisp
  (require 'cl-lib)

  (setq lexical-binding t)
  (defconst unforced (cl-gensym)
    "delay对象尚未求值的标志")

  (cl-defstruct delay                     ;定义delay结构体,其由两个部分组成
    forced                                ;forced代表该delay结构体是否已经求值,若求过值,则直接使用该值
    closure)                              ;closure为一个闭包,调用它就能得到该delay所代表的值

  (defmacro delay (expr)
    "使用该宏,将`expr'封装成一个惰性求值对象"
    (let ((self (gensym)))
      `(let ((,self (make-delay :forced unforced
                                :closure #'(lambda ()
                                             (setf (delay-forced ,self) ,expr)))))
         ,self)))

  (defun force (x)
    "对delay对象求值
  若x不是delay对象则直接返回x,否则返回其表示的值"
    (if (delay-p x)
        (if (eq (delay-forced x) unforced)
            (funcall (delay-closure x))
          (delay-forced x))
      x))

#+END_SRC
